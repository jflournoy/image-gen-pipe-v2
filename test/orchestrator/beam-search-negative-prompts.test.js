/**
 * Tests for Beam Search integration with auto-generated negative prompts
 * TDD RED phase - these tests should fail initially
 */

const { describe, it, before } = require('node:test');
const assert = require('node:assert');
const beamSearch = require('../../src/orchestrator/beam-search');

describe('Beam Search - Negative Prompt Integration', () => {
  let mockProviders;
  let mockNegativePromptGenerator;

  before(() => {
    // Mock LLM provider
    const mockLLMProvider = {
      async refinePrompt(prompt, _options) {
        return {
          refinedPrompt: `refined: ${prompt}`,
          metadata: { model: 'mock-llm', tokens: 100 }
        };
      },
      async combinePrompts(what, how, _options) {
        return {
          combinedPrompt: `${what}, ${how}`,
          metadata: { model: 'mock-llm', tokens: 150 }
        };
      }
    };

    // Mock Image provider (SDXL)
    const mockImageProvider = {
      modelType: 'sdxl',  // Key: this is an SDXL model
      async generateImage(prompt, options = {}) {
        return {
          url: 'http://example.com/image.png',
          localPath: '/tmp/image.png',
          metadata: {
            model: 'sdxl-base',
            prompt: prompt,
            negative_prompt: options.negativePrompt || null,  // Should receive negative prompt
            seed: 12345
          }
        };
      }
    };

    // Mock Vision provider
    const mockVisionProvider = {
      async analyzeImage(_imageReference, _combinedPrompt) {
        return {
          alignmentScore: 85,
          aestheticScore: 9.0,
          metadata: {
            model: 'mock-vision',
            tokensUsed: 200
          }
        };
      }
    };

    // Mock Negative Prompt Generator
    mockNegativePromptGenerator = {
      async generateNegativePrompt(_positivePrompt, _options) {
        return {
          negativePrompt: 'blurry, low quality, distorted',
          metadata: {
            autoGenerated: true,
            generationTime: 500,
            model: 'mistral-7b'
          }
        };
      }
    };

    mockProviders = {
      llmProvider: mockLLMProvider,
      imageGenProvider: mockImageProvider,
      visionProvider: mockVisionProvider,
      negativePromptGenerator: mockNegativePromptGenerator  // New provider
    };
  });

  describe('SDXL model detection', () => {
    it('should detect SDXL models and generate negative prompts', async () => {
      const providers = {
        llm: mockProviders.llmProvider,
        imageGen: mockProviders.imageGenProvider,
        vision: mockProviders.visionProvider,
        critiqueGen: { async generateCritique() { return { critique: 'test' }; } }
      };

      const config = {
        beamWidth: 1,
        maxIterations: 1,
        keepTop: 1,
        autoGenerateNegativePrompts: true,  // Enable auto-generation
        negativePromptGenerator: mockProviders.negativePromptGenerator,
        onStepProgress: () => {}
      };

      const result = await beamSearch.beamSearch('a beautiful sunset', providers, config);

      // Should have generated and used negative prompt
      assert.ok(result.image, 'Should have generated image');
      assert.ok(result.image.metadata, 'Should have image metadata');
      assert.ok(result.image.metadata.negative_prompt, 'Should include negative prompt in metadata');
      assert.strictEqual(
        result.image.metadata.negative_prompt,
        'blurry, low quality, distorted',
        'Should use auto-generated negative prompt'
      );
    });

    it('should skip negative prompt generation when disabled', async () => {
      const providers = {
        llm: mockProviders.llmProvider,
        imageGen: mockProviders.imageGenProvider,
        vision: mockProviders.visionProvider,
        critiqueGen: { async generateCritique() { return { critique: 'test' }; } }
      };

      const config = {
        beamWidth: 1,
        maxIterations: 1,
        keepTop: 1,
        autoGenerateNegativePrompts: false,  // Disabled
        negativePromptGenerator: mockProviders.negativePromptGenerator,
        onStepProgress: () => {}
      };

      const result = await beamSearch.beamSearch('a beautiful sunset', providers, config);

      // Should not have negative prompt when disabled
      assert.strictEqual(
        result.image.metadata.negative_prompt,
        null,
        'Should not generate negative prompt when disabled'
      );
    });

    it('should allow manual negative prompt override', async () => {
      const manualNegative = 'ugly, bad quality, amateur';

      const providers = {
        llm: mockProviders.llmProvider,
        imageGen: mockProviders.imageGenProvider,
        vision: mockProviders.visionProvider,
        critiqueGen: { async generateCritique() { return { critique: 'test' }; } }
      };

      const config = {
        beamWidth: 1,
        maxIterations: 1,
        keepTop: 1,
        autoGenerateNegativePrompts: false,
        negativePrompt: manualNegative,  // Manual override
        onStepProgress: () => {}
      };

      const result = await beamSearch.beamSearch('a beautiful sunset', providers, config);

      assert.strictEqual(
        result.image.metadata.negative_prompt,
        manualNegative,
        'Should use manual negative prompt'
      );
    });
  });

  describe('Non-SDXL model handling', () => {
    it('should skip negative prompts for Flux models', async () => {
      // Create Flux provider
      const fluxProvider = {
        modelType: 'flux',  // Not SDXL
        async generateImage(prompt, options = {}) {
          return {
            url: 'http://example.com/image.png',
            localPath: '/tmp/image.png',
            metadata: {
              model: 'flux-dev',
              prompt: prompt,
              negative_prompt: options.negativePrompt || null,
              seed: 12345
            }
          };
        }
      };

      const providers = {
        llm: mockProviders.llmProvider,
        imageGen: fluxProvider,
        vision: mockProviders.visionProvider,
        critiqueGen: { async generateCritique() { return { critique: 'test' }; } }
      };

      const config = {
        beamWidth: 1,
        maxIterations: 1,
        keepTop: 1,
        autoGenerateNegativePrompts: true,  // Enabled but should skip for Flux
        negativePromptGenerator: mockNegativePromptGenerator,
        onStepProgress: () => {}
      };

      const result = await beamSearch.beamSearch('a beautiful sunset', providers, config);

      // Flux doesn't support negative prompts, should not call generator
      // For Flux, negative_prompt should be undefined or not present
      assert.ok(
        !result.image.metadata.negative_prompt,
        'Should not generate negative prompt for Flux models'
      );
    });
  });

  describe('Progress reporting', () => {
    it('should report negative prompt generation progress', async () => {
      const progressMessages = [];

      const providers = {
        llm: mockProviders.llmProvider,
        imageGen: mockProviders.imageGenProvider,
        vision: mockProviders.visionProvider,
        critiqueGen: { async generateCritique() { return { critique: 'test' }; } }
      };

      const config = {
        beamWidth: 1,
        maxIterations: 1,
        keepTop: 1,
        autoGenerateNegativePrompts: true,
        negativePromptGenerator: mockProviders.negativePromptGenerator,
        onStepProgress: (progress) => {
          progressMessages.push(progress);
        }
      };

      await beamSearch.beamSearch('a beautiful sunset', providers, config);

      // Should have progress message for negative prompt generation
      const negativePromptProgress = progressMessages.find(
        p => p.stage === 'negativePrompt' || p.message?.includes('negative prompt')
      );

      assert.ok(
        negativePromptProgress,
        'Should report progress during negative prompt generation'
      );
    });
  });

  describe('Error handling', () => {
    it('should fall back to default negative when generator fails', async () => {
      const failingGenerator = {
        async generateNegativePrompt() {
          throw new Error('LLM service unavailable');
        }
      };

      const providers = {
        llm: mockProviders.llmProvider,
        imageGen: mockProviders.imageGenProvider,
        vision: mockProviders.visionProvider,
        critiqueGen: { async generateCritique() { return { critique: 'test' }; } }
      };

      const config = {
        beamWidth: 1,
        maxIterations: 1,
        keepTop: 1,
        autoGenerateNegativePrompts: true,
        negativePromptGenerator: failingGenerator,
        negativePromptFallback: 'blurry, low quality',  // Fallback
        onStepProgress: () => {}
      };

      const result = await beamSearch.beamSearch('a beautiful sunset', providers, config);

      // Should use fallback when generator fails
      assert.ok(
        result.image.metadata.negative_prompt,
        'Should have some negative prompt (fallback)'
      );
    });
  });
});
